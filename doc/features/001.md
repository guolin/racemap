# Feature 001: 核心性能和稳定性优化

> **创建时间**: 2025-01-12  
> **优先级**: P0 (高)  
> **估时**: 2-3天  
> **状态**: 待实施

## 📋 摘要

基于代码分析，针对帆船裁判实时定位系统的实际使用场景（3-10人小团队，高精度要求，网络状态优先）进行核心优化。主要解决参数变化引起的频繁重渲染问题，提升GPS精度，增强网络状态显示。

### 核心问题
- `RaceMap.tsx` 中 `params` 对象引用变化导致MQTT频繁发布
- GPS位置精度阈值过大（1米），不满足帆船比赛需求
- 网络状态显示不够突出，断网时用户感知不明显
- 观察者列表显示可优化，更适合小团队协作

## 🔧 改动文件

### 1. 核心修复文件
- `src/features/map/RaceMap.tsx` - 修复params引用问题
- `src/features/mqtt/hooks/useMqttPosSync.ts` - 调整位置精度阈值
- `src/features/map/components/TopBar.tsx` - 增强网络状态显示

### 2. 新增文件
- `src/features/network/hooks/useNetworkStatus.ts` - 网络状态管理Hook
- `src/features/map/components/NetworkIndicator.tsx` - 网络状态指示器
- `src/features/map/components/ObserversList.tsx` - 优化的观察者列表

### 3. 配置调整
- `context/GpsContext.tsx` - GPS配置优化

## 🎯 具体改动内容

### 1. 修复频繁重渲染问题

**文件**: `src/features/map/RaceMap.tsx`

```typescript
// 问题代码 (第235-239行)
useEffect(() => {
  if (isAdmin && publishNow) publishNow();
}, [isAdmin, type, params]); // params对象引用频繁变化

// 修复后 - 使用稳定的参数序列化
const paramsHash = useMemo(() => {
  // 稳定序列化，避免key顺序问题
  const keys = Object.keys(params).sort();
  const stable = keys.reduce((acc, key) => {
    acc[key] = params[key];
    return acc;
  }, {} as typeof params);
  return JSON.stringify(stable);
}, [params]);

useEffect(() => {
  if (isAdmin && publishNow) publishNow();
}, [isAdmin, type, paramsHash]); // 使用稳定hash避免引用比较
```

### 2. 提升GPS位置精度和发布控制

**文件**: `src/features/mqtt/hooks/useMqttPosSync.ts`

```typescript
// 当前阈值 (第52行)
const POSITION_THRESHOLD = 0.00001; // 约1米

// 优化为更高精度，并增加发布间隔控制
const POSITION_THRESHOLD = 0.000005; // 约0.5米，满足帆船比赛精度需求
const MIN_PUBLISH_INTERVAL = 2000; // 最少2秒间隔，避免GPS抖动

// 增加时间戳引用
const lastPublishTimeRef = useRef<number>(0);

const tryPublish = () => {
  if (!client.connected) {
    console.debug('[MQTT] Skip publishing, client not connected');
    return;
  }
  
  const pos = getLatestPosRef.current();
  if (!pos) {
    console.debug('[MQTT] Skip publishing, no position available');
    return;
  }
  
  // 检查最小发布间隔
  const now = Date.now();
  if (now - lastPublishTimeRef.current < MIN_PUBLISH_INTERVAL) {
    console.debug('[MQTT] Skip publishing, within minimum interval');
    return;
  }
  
  // ... 现有发布逻辑保持不变
  
  try {
    const { type, params } = getCourseDataRef.current();
    const payloadStr = JSON.stringify({ 
      id: 'ADMIN',
      lat: pos.lat,
      lng: pos.lng,
      course: { type, params },
      timestamp: now
    });
    
    client.publish(posTopic(courseId), payloadStr, { retain: true, qos: 1 }, (err) => {
      if (err) {
        console.error('[MQTT] Failed to publish:', err);
        return;
      }
      console.debug('[MQTT] Published position update');
      lastPublishTimeRef.current = now; // 记录成功发布时间
      lastPayloadRef.current = JSON.stringify({
        lat: pos.lat,
        lng: pos.lng,
        course: { type, params }
      });
    });
  } catch (e) {
    console.error('[MQTT] Error preparing payload:', e);
  }
};
```

### 3. 新增网络状态管理Hook

**文件**: `src/features/network/hooks/useNetworkStatus.ts`

```typescript
export interface NetworkStatus {
  status: 'online' | 'offline' | 'mqtt_error' | 'stale';
  message: string;
  isHealthy: boolean;
}

export function useNetworkStatus(mqttClient?: MqttClient): NetworkStatus {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [mqttConnected, setMqttConnected] = useState(false);
  const [lastSyncTime, setLastSyncTime] = useState<number | null>(null);
  
  // 监听网络状态
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  // 监听MQTT连接状态 - 修正事件名
  useEffect(() => {
    if (!mqttClient) return;
    
    const handleConnect = () => {
      setMqttConnected(true);
      setLastSyncTime(Date.now());
    };
    const handleOffline = () => setMqttConnected(false);
    const handleMessage = () => setLastSyncTime(Date.now());
    
    mqttClient.on('connect', handleConnect);
    mqttClient.on('reconnect', handleConnect);  
    mqttClient.on('offline', handleOffline);
    mqttClient.on('close', handleOffline);
    mqttClient.on('error', handleOffline);
    mqttClient.on('message', handleMessage); // 更新同步时间
    
    return () => {
      mqttClient.off('connect', handleConnect);
      mqttClient.off('reconnect', handleConnect);
      mqttClient.off('offline', handleOffline);
      mqttClient.off('close', handleOffline);
      mqttClient.off('error', handleOffline);
      mqttClient.off('message', handleMessage);
    };
  }, [mqttClient]);
  
  return useMemo(() => {
    if (!isOnline) return { 
      status: 'offline', 
      message: '网络已断开', 
      isHealthy: false 
    };
    
    if (!mqttConnected) return { 
      status: 'mqtt_error', 
      message: 'MQTT连接中...', 
      isHealthy: false 
    };
    
    if (lastSyncTime && Date.now() - lastSyncTime > 30000) {
      return { 
        status: 'stale', 
        message: '数据可能过期', 
        isHealthy: false 
      };
    }
    
    return { 
      status: 'online', 
      message: '实时同步中', 
      isHealthy: true 
    };
  }, [isOnline, mqttConnected, lastSyncTime]);
}
```

### 4. 网络状态指示器组件

**文件**: `src/features/map/components/NetworkIndicator.tsx`

```typescript
interface NetworkIndicatorProps {
  status: NetworkStatus;
  className?: string;
}

export const NetworkIndicator: React.FC<NetworkIndicatorProps> = ({ 
  status, 
  className = '' 
}) => {
  const statusConfig = {
    online: { 
      color: 'bg-green-500', 
      icon: '🟢',
      priority: 'low' 
    },
    offline: { 
      color: 'bg-red-500 animate-pulse', 
      icon: '🔴',
      priority: 'critical' 
    },
    mqtt_error: { 
      color: 'bg-yellow-500 animate-pulse', 
      icon: '🟡',
      priority: 'high' 
    },
    stale: { 
      color: 'bg-orange-500', 
      icon: '🟠',
      priority: 'medium' 
    }
  };
  
  const config = statusConfig[status.status];
  
  return (
    <div className={`
      flex items-center gap-1 px-2 py-1 rounded text-xs font-bold text-white
      ${config.color} ${className}
      ${config.priority === 'critical' ? 'ring-2 ring-red-300' : ''}
    `}>
      <span>{config.icon}</span>
      <span>{status.message}</span>
    </div>
  );
};
```

### 5. 优化观察者列表显示

**文件**: `src/features/map/components/ObserversList.tsx`

```typescript
interface ObserversListProps {
  observers: ObserverPos[];
  currentObserverId: string;
}

export const ObserversList: React.FC<ObserversListProps> = ({ 
  observers, 
  currentObserverId 
}) => {
  const sortedObservers = useMemo(() => 
    observers
      .filter(obs => obs.id !== currentObserverId) // 排除自己
      .sort((a, b) => b.ts - a.ts) // 按最新时间排序，使用实际字段名
  , [observers, currentObserverId]);

  return (
    <div className="absolute top-20 right-4 bg-black/80 text-white rounded-lg p-3 text-xs min-w-[180px]">
      <div className="font-bold mb-2 flex items-center gap-2">
        <span>在线裁判</span>
        <span className="bg-blue-500 px-1.5 py-0.5 rounded">
          {sortedObservers.length + 1}
        </span>
      </div>
      
      {/* 自己的状态 */}
      <div className="flex items-center gap-2 mb-2 p-1 bg-blue-500/20 rounded">
        <div className="w-2 h-2 rounded-full bg-blue-400" />
        <span className="font-medium">{currentObserverId} (我)</span>
      </div>
      
      {/* 其他观察者 */}
      {sortedObservers.map(obs => {
        const timeDiff = Date.now() - obs.ts; // 使用实际字段名 ts
        const isRecent = timeDiff < 10000; // 10秒内
        const secondsAgo = Math.round(timeDiff / 1000);
        
        return (
          <div key={obs.id} className="flex items-center gap-2 mb-1 p-1 rounded hover:bg-white/10">
            <div className={`w-2 h-2 rounded-full ${
              isRecent ? 'bg-green-400' : 'bg-yellow-400'
            }`} />
            <span className="flex-1">{obs.id}</span>
            <span className={`text-xs ${
              isRecent ? 'text-green-300' : 'text-yellow-300'
            }`}>
              {secondsAgo}s前
            </span>
          </div>
        );
      })}
      
      {sortedObservers.length === 0 && (
        <div className="text-gray-400 text-center py-2">
          暂无其他裁判在线
        </div>
      )}
    </div>
  );
};
```

### 6. GPS配置优化

**文件**: `context/GpsContext.tsx`

```typescript
// 当前GpsContext配置 (第72行)
navigator.geolocation.getCurrentPosition(handleSuccess, handleError, { 
  enableHighAccuracy: true, 
  maximumAge: 0, 
  timeout: 2000  // 当前2秒超时
});

// 建议优化为与useGpsWatch对齐，提高超时时间确保高精度
navigator.geolocation.getCurrentPosition(handleSuccess, handleError, { 
  enableHighAccuracy: true, 
  maximumAge: 0,        // 保持不使用缓存
  timeout: 5000         // 提升到5秒或与useGpsWatch的10秒对齐
});

// watchPosition配置同步调整 (第86-91行)
watchIdRef.current = watchPositionThrottled(handleSuccess, handleError, {
  enableHighAccuracy: true,
  maximumAge: 0,
  timeout: 5000,        // 从2000ms提升到5000ms
  throttleTime: throttleMs,
});
```

**注意**: 主要组件使用的是`useGpsWatch` (已有10秒超时)，此调整主要影响仍在使用`GpsContext`的场景。

### 7. 在RaceMap中集成网络状态

**文件**: `src/features/map/RaceMap.tsx`

```typescript
// TopBar当前是插槽式结构，不需要修改TopBar本身
// 在RaceMap中添加网络状态到TopBar的left插槽

export default function RaceMap({ courseId, isAdmin = false }: Props) {
  const client = useMqttClient(); // 导入现有的客户端hook
  const networkStatus = useNetworkStatus(client);
  
  // ... 现有逻辑保持不变
  
  return (
    <div 
      className="relative w-screen" 
      style={{ height: viewportHeight > 0 ? viewportHeight : '100vh' }}
    >
      <div id="map-root" className="w-full h-full" />
      
      <TopBar 
        left={<NetworkIndicator status={networkStatus} />} // 新增网络状态到left插槽
        center={centerContent} 
        right={<OnlineCount count={onlineCount} />} 
      />
      
      {/* 新增观察者列表 */}
      {!isAdmin && (
        <ObserversList 
          observers={observers} 
          currentObserverId={observerIdRef.current} 
        />
      )}
      
      {/* ... 其余UI保持不变 */}
    </div>
  );
}
```

**注意**: TopBar组件支持`left`、`center`、`right`三个插槽，网络状态适合放在`left`位置。

## ✅ 验收标准

### 功能验收
1. [ ] 修复后不再因课程参数微调频繁触发MQTT发布
2. [ ] GPS位置同步精度提升到0.5米级别
3. [ ] 网络断开时有明显的视觉提示
4. [ ] 观察者列表清晰显示在线状态和最后同步时间

### 性能验收
1. [ ] RaceMap组件重渲染频率显著降低
2. [ ] MQTT消息发布频率控制在2秒最小间隔
3. [ ] 网络状态检查不影响主要功能性能

### 用户体验验收
1. [ ] 网络问题能第一时间被用户察觉
2. [ ] 观察者列表信息一目了然，适合小团队使用
3. [ ] GPS精度满足帆船比赛专业需求

## 🚀 实施计划

### Day 1
- 修复RaceMap.tsx的params引用问题
- 实现useNetworkStatus Hook
- 调整GPS配置和位置精度阈值

### Day 2  
- 实现NetworkIndicator组件
- 实现ObserversList组件
- 集成到TopBar和RaceMap

### Day 3
- 全面测试和调优
- 验收标准检查
- 文档更新

## 📝 注意事项和代码审查反馈

### 基于实际代码审查的修正点

1. **MQTT事件名修正**: 使用正确的mqtt.js事件名 (`connect`, `reconnect`, `offline`, `close`, `error`)，避免不存在的 `disconnect` 事件
2. **观察者数据字段**: 使用实际的字段名 `obs.ts` 而不是 `obs.timestamp`
3. **TopBar插槽结构**: 利用现有的 `left`、`center`、`right` 插槽，无需修改TopBar组件本身
4. **GPS配置影响范围**: 主要影响仍使用GpsContext的场景，核心功能使用useGpsWatch已有较好配置
5. **参数序列化稳定性**: 使用键排序确保JSON序列化的稳定性，避免key顺序导致的误触发

### 实施细节

1. **保持架构简单**: 不引入复杂的状态管理，维持现有的Hook模式
2. **向后兼容**: 所有改动保持与现有功能的兼容性  
3. **测试重点**: 重点测试网络不稳定情况下的表现，验证参数变化时的发布频率
4. **移动端适配**: 确保新增UI在手机屏幕上正常显示
5. **性能监控**: 关注JSON.stringify的性能开销，必要时考虑浅层比较优化

## 🔗 相关文档

- [项目架构文档](../架构与业务逻辑.md)
- [MQTT通信协议](../README.md#核心功能)
- [GPS精度要求说明](../需求文档.md)